/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.1
 * source: gravity/v1/msgs.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../cosmos/base/v1beta1/coin";
import * as dependency_2 from "./../../gogoproto/gogo";
import * as dependency_3 from "./../../google/api/annotations";
import * as dependency_4 from "./types";
import * as dependency_5 from "./../../google/protobuf/any";
import * as dependency_6 from "./../../cosmos_proto/cosmos";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace gravity.v1 {
    export class MsgSetOrchestratorAddress extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            validator?: string;
            orchestrator?: string;
            eth_address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validator" in data && data.validator != undefined) {
                    this.validator = data.validator;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
                if ("eth_address" in data && data.eth_address != undefined) {
                    this.eth_address = data.eth_address;
                }
            }
        }
        get validator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set validator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get eth_address() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set eth_address(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            validator?: string;
            orchestrator?: string;
            eth_address?: string;
        }): MsgSetOrchestratorAddress {
            const message = new MsgSetOrchestratorAddress({});
            if (data.validator != null) {
                message.validator = data.validator;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            if (data.eth_address != null) {
                message.eth_address = data.eth_address;
            }
            return message;
        }
        toObject() {
            const data: {
                validator?: string;
                orchestrator?: string;
                eth_address?: string;
            } = {};
            if (this.validator != null) {
                data.validator = this.validator;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            if (this.eth_address != null) {
                data.eth_address = this.eth_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.validator.length)
                writer.writeString(1, this.validator);
            if (this.orchestrator.length)
                writer.writeString(2, this.orchestrator);
            if (this.eth_address.length)
                writer.writeString(3, this.eth_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSetOrchestratorAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSetOrchestratorAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.validator = reader.readString();
                        break;
                    case 2:
                        message.orchestrator = reader.readString();
                        break;
                    case 3:
                        message.eth_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSetOrchestratorAddress {
            return MsgSetOrchestratorAddress.deserialize(bytes);
        }
    }
    export class MsgSetOrchestratorAddressResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgSetOrchestratorAddressResponse {
            const message = new MsgSetOrchestratorAddressResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSetOrchestratorAddressResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSetOrchestratorAddressResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSetOrchestratorAddressResponse {
            return MsgSetOrchestratorAddressResponse.deserialize(bytes);
        }
    }
    export class MsgValsetConfirm extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            nonce?: number;
            orchestrator?: string;
            eth_address?: string;
            signature?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
                if ("eth_address" in data && data.eth_address != undefined) {
                    this.eth_address = data.eth_address;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get eth_address() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set eth_address(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            nonce?: number;
            orchestrator?: string;
            eth_address?: string;
            signature?: string;
        }): MsgValsetConfirm {
            const message = new MsgValsetConfirm({});
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            if (data.eth_address != null) {
                message.eth_address = data.eth_address;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                nonce?: number;
                orchestrator?: string;
                eth_address?: string;
                signature?: string;
            } = {};
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            if (this.eth_address != null) {
                data.eth_address = this.eth_address;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.nonce != 0)
                writer.writeUint64(1, this.nonce);
            if (this.orchestrator.length)
                writer.writeString(2, this.orchestrator);
            if (this.eth_address.length)
                writer.writeString(3, this.eth_address);
            if (this.signature.length)
                writer.writeString(4, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgValsetConfirm {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgValsetConfirm();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.nonce = reader.readUint64();
                        break;
                    case 2:
                        message.orchestrator = reader.readString();
                        break;
                    case 3:
                        message.eth_address = reader.readString();
                        break;
                    case 4:
                        message.signature = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgValsetConfirm {
            return MsgValsetConfirm.deserialize(bytes);
        }
    }
    export class MsgValsetConfirmResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgValsetConfirmResponse {
            const message = new MsgValsetConfirmResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgValsetConfirmResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgValsetConfirmResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgValsetConfirmResponse {
            return MsgValsetConfirmResponse.deserialize(bytes);
        }
    }
    export class MsgSendToEth extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sender?: string;
            eth_dest?: string;
            amount?: dependency_1.cosmos.base.v1beta1.Coin;
            bridge_fee?: dependency_1.cosmos.base.v1beta1.Coin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("eth_dest" in data && data.eth_dest != undefined) {
                    this.eth_dest = data.eth_dest;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("bridge_fee" in data && data.bridge_fee != undefined) {
                    this.bridge_fee = data.bridge_fee;
                }
            }
        }
        get sender() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get eth_dest() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set eth_dest(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.cosmos.base.v1beta1.Coin, 3) as dependency_1.cosmos.base.v1beta1.Coin;
        }
        set amount(value: dependency_1.cosmos.base.v1beta1.Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get bridge_fee() {
            return pb_1.Message.getWrapperField(this, dependency_1.cosmos.base.v1beta1.Coin, 4) as dependency_1.cosmos.base.v1beta1.Coin;
        }
        set bridge_fee(value: dependency_1.cosmos.base.v1beta1.Coin) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_bridge_fee() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            sender?: string;
            eth_dest?: string;
            amount?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
            bridge_fee?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
        }): MsgSendToEth {
            const message = new MsgSendToEth({});
            if (data.sender != null) {
                message.sender = data.sender;
            }
            if (data.eth_dest != null) {
                message.eth_dest = data.eth_dest;
            }
            if (data.amount != null) {
                message.amount = dependency_1.cosmos.base.v1beta1.Coin.fromObject(data.amount);
            }
            if (data.bridge_fee != null) {
                message.bridge_fee = dependency_1.cosmos.base.v1beta1.Coin.fromObject(data.bridge_fee);
            }
            return message;
        }
        toObject() {
            const data: {
                sender?: string;
                eth_dest?: string;
                amount?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
                bridge_fee?: ReturnType<typeof dependency_1.cosmos.base.v1beta1.Coin.prototype.toObject>;
            } = {};
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.eth_dest != null) {
                data.eth_dest = this.eth_dest;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.bridge_fee != null) {
                data.bridge_fee = this.bridge_fee.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sender.length)
                writer.writeString(1, this.sender);
            if (this.eth_dest.length)
                writer.writeString(2, this.eth_dest);
            if (this.has_amount)
                writer.writeMessage(3, this.amount, () => this.amount.serialize(writer));
            if (this.has_bridge_fee)
                writer.writeMessage(4, this.bridge_fee, () => this.bridge_fee.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSendToEth {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSendToEth();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sender = reader.readString();
                        break;
                    case 2:
                        message.eth_dest = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => message.amount = dependency_1.cosmos.base.v1beta1.Coin.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.bridge_fee, () => message.bridge_fee = dependency_1.cosmos.base.v1beta1.Coin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSendToEth {
            return MsgSendToEth.deserialize(bytes);
        }
    }
    export class MsgSendToEthResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgSendToEthResponse {
            const message = new MsgSendToEthResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSendToEthResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSendToEthResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSendToEthResponse {
            return MsgSendToEthResponse.deserialize(bytes);
        }
    }
    export class MsgRequestBatch extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sender?: string;
            denom?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("denom" in data && data.denom != undefined) {
                    this.denom = data.denom;
                }
            }
        }
        get sender() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get denom() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set denom(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            sender?: string;
            denom?: string;
        }): MsgRequestBatch {
            const message = new MsgRequestBatch({});
            if (data.sender != null) {
                message.sender = data.sender;
            }
            if (data.denom != null) {
                message.denom = data.denom;
            }
            return message;
        }
        toObject() {
            const data: {
                sender?: string;
                denom?: string;
            } = {};
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.denom != null) {
                data.denom = this.denom;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sender.length)
                writer.writeString(1, this.sender);
            if (this.denom.length)
                writer.writeString(2, this.denom);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgRequestBatch {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgRequestBatch();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sender = reader.readString();
                        break;
                    case 2:
                        message.denom = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgRequestBatch {
            return MsgRequestBatch.deserialize(bytes);
        }
    }
    export class MsgRequestBatchResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgRequestBatchResponse {
            const message = new MsgRequestBatchResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgRequestBatchResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgRequestBatchResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgRequestBatchResponse {
            return MsgRequestBatchResponse.deserialize(bytes);
        }
    }
    export class MsgConfirmBatch extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            nonce?: number;
            token_contract?: string;
            eth_signer?: string;
            orchestrator?: string;
            signature?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
                if ("token_contract" in data && data.token_contract != undefined) {
                    this.token_contract = data.token_contract;
                }
                if ("eth_signer" in data && data.eth_signer != undefined) {
                    this.eth_signer = data.eth_signer;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get token_contract() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set token_contract(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get eth_signer() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set eth_signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            nonce?: number;
            token_contract?: string;
            eth_signer?: string;
            orchestrator?: string;
            signature?: string;
        }): MsgConfirmBatch {
            const message = new MsgConfirmBatch({});
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            if (data.token_contract != null) {
                message.token_contract = data.token_contract;
            }
            if (data.eth_signer != null) {
                message.eth_signer = data.eth_signer;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                nonce?: number;
                token_contract?: string;
                eth_signer?: string;
                orchestrator?: string;
                signature?: string;
            } = {};
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            if (this.token_contract != null) {
                data.token_contract = this.token_contract;
            }
            if (this.eth_signer != null) {
                data.eth_signer = this.eth_signer;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.nonce != 0)
                writer.writeUint64(1, this.nonce);
            if (this.token_contract.length)
                writer.writeString(2, this.token_contract);
            if (this.eth_signer.length)
                writer.writeString(3, this.eth_signer);
            if (this.orchestrator.length)
                writer.writeString(4, this.orchestrator);
            if (this.signature.length)
                writer.writeString(5, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConfirmBatch {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConfirmBatch();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.nonce = reader.readUint64();
                        break;
                    case 2:
                        message.token_contract = reader.readString();
                        break;
                    case 3:
                        message.eth_signer = reader.readString();
                        break;
                    case 4:
                        message.orchestrator = reader.readString();
                        break;
                    case 5:
                        message.signature = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConfirmBatch {
            return MsgConfirmBatch.deserialize(bytes);
        }
    }
    export class MsgConfirmBatchResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgConfirmBatchResponse {
            const message = new MsgConfirmBatchResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConfirmBatchResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConfirmBatchResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConfirmBatchResponse {
            return MsgConfirmBatchResponse.deserialize(bytes);
        }
    }
    export class MsgConfirmLogicCall extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            invalidation_id?: string;
            invalidation_nonce?: number;
            eth_signer?: string;
            orchestrator?: string;
            signature?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("invalidation_id" in data && data.invalidation_id != undefined) {
                    this.invalidation_id = data.invalidation_id;
                }
                if ("invalidation_nonce" in data && data.invalidation_nonce != undefined) {
                    this.invalidation_nonce = data.invalidation_nonce;
                }
                if ("eth_signer" in data && data.eth_signer != undefined) {
                    this.eth_signer = data.eth_signer;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get invalidation_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set invalidation_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get invalidation_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set invalidation_nonce(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get eth_signer() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set eth_signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            invalidation_id?: string;
            invalidation_nonce?: number;
            eth_signer?: string;
            orchestrator?: string;
            signature?: string;
        }): MsgConfirmLogicCall {
            const message = new MsgConfirmLogicCall({});
            if (data.invalidation_id != null) {
                message.invalidation_id = data.invalidation_id;
            }
            if (data.invalidation_nonce != null) {
                message.invalidation_nonce = data.invalidation_nonce;
            }
            if (data.eth_signer != null) {
                message.eth_signer = data.eth_signer;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                invalidation_id?: string;
                invalidation_nonce?: number;
                eth_signer?: string;
                orchestrator?: string;
                signature?: string;
            } = {};
            if (this.invalidation_id != null) {
                data.invalidation_id = this.invalidation_id;
            }
            if (this.invalidation_nonce != null) {
                data.invalidation_nonce = this.invalidation_nonce;
            }
            if (this.eth_signer != null) {
                data.eth_signer = this.eth_signer;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.invalidation_id.length)
                writer.writeString(1, this.invalidation_id);
            if (this.invalidation_nonce != 0)
                writer.writeUint64(2, this.invalidation_nonce);
            if (this.eth_signer.length)
                writer.writeString(3, this.eth_signer);
            if (this.orchestrator.length)
                writer.writeString(4, this.orchestrator);
            if (this.signature.length)
                writer.writeString(5, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConfirmLogicCall {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConfirmLogicCall();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.invalidation_id = reader.readString();
                        break;
                    case 2:
                        message.invalidation_nonce = reader.readUint64();
                        break;
                    case 3:
                        message.eth_signer = reader.readString();
                        break;
                    case 4:
                        message.orchestrator = reader.readString();
                        break;
                    case 5:
                        message.signature = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConfirmLogicCall {
            return MsgConfirmLogicCall.deserialize(bytes);
        }
    }
    export class MsgConfirmLogicCallResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgConfirmLogicCallResponse {
            const message = new MsgConfirmLogicCallResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConfirmLogicCallResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConfirmLogicCallResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConfirmLogicCallResponse {
            return MsgConfirmLogicCallResponse.deserialize(bytes);
        }
    }
    export class MsgSendToCosmosClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            event_nonce?: number;
            block_height?: number;
            token_contract?: string;
            amount?: string;
            ethereum_sender?: string;
            cosmos_receiver?: string;
            orchestrator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_nonce" in data && data.event_nonce != undefined) {
                    this.event_nonce = data.event_nonce;
                }
                if ("block_height" in data && data.block_height != undefined) {
                    this.block_height = data.block_height;
                }
                if ("token_contract" in data && data.token_contract != undefined) {
                    this.token_contract = data.token_contract;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("ethereum_sender" in data && data.ethereum_sender != undefined) {
                    this.ethereum_sender = data.ethereum_sender;
                }
                if ("cosmos_receiver" in data && data.cosmos_receiver != undefined) {
                    this.cosmos_receiver = data.cosmos_receiver;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
            }
        }
        get event_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set event_nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get block_height() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set block_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get token_contract() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set token_contract(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get amount() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set amount(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get ethereum_sender() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set ethereum_sender(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get cosmos_receiver() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set cosmos_receiver(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            event_nonce?: number;
            block_height?: number;
            token_contract?: string;
            amount?: string;
            ethereum_sender?: string;
            cosmos_receiver?: string;
            orchestrator?: string;
        }): MsgSendToCosmosClaim {
            const message = new MsgSendToCosmosClaim({});
            if (data.event_nonce != null) {
                message.event_nonce = data.event_nonce;
            }
            if (data.block_height != null) {
                message.block_height = data.block_height;
            }
            if (data.token_contract != null) {
                message.token_contract = data.token_contract;
            }
            if (data.amount != null) {
                message.amount = data.amount;
            }
            if (data.ethereum_sender != null) {
                message.ethereum_sender = data.ethereum_sender;
            }
            if (data.cosmos_receiver != null) {
                message.cosmos_receiver = data.cosmos_receiver;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            return message;
        }
        toObject() {
            const data: {
                event_nonce?: number;
                block_height?: number;
                token_contract?: string;
                amount?: string;
                ethereum_sender?: string;
                cosmos_receiver?: string;
                orchestrator?: string;
            } = {};
            if (this.event_nonce != null) {
                data.event_nonce = this.event_nonce;
            }
            if (this.block_height != null) {
                data.block_height = this.block_height;
            }
            if (this.token_contract != null) {
                data.token_contract = this.token_contract;
            }
            if (this.amount != null) {
                data.amount = this.amount;
            }
            if (this.ethereum_sender != null) {
                data.ethereum_sender = this.ethereum_sender;
            }
            if (this.cosmos_receiver != null) {
                data.cosmos_receiver = this.cosmos_receiver;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_nonce != 0)
                writer.writeUint64(1, this.event_nonce);
            if (this.block_height != 0)
                writer.writeUint64(2, this.block_height);
            if (this.token_contract.length)
                writer.writeString(3, this.token_contract);
            if (this.amount.length)
                writer.writeString(4, this.amount);
            if (this.ethereum_sender.length)
                writer.writeString(5, this.ethereum_sender);
            if (this.cosmos_receiver.length)
                writer.writeString(6, this.cosmos_receiver);
            if (this.orchestrator.length)
                writer.writeString(7, this.orchestrator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSendToCosmosClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSendToCosmosClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_nonce = reader.readUint64();
                        break;
                    case 2:
                        message.block_height = reader.readUint64();
                        break;
                    case 3:
                        message.token_contract = reader.readString();
                        break;
                    case 4:
                        message.amount = reader.readString();
                        break;
                    case 5:
                        message.ethereum_sender = reader.readString();
                        break;
                    case 6:
                        message.cosmos_receiver = reader.readString();
                        break;
                    case 7:
                        message.orchestrator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSendToCosmosClaim {
            return MsgSendToCosmosClaim.deserialize(bytes);
        }
    }
    export class MsgSendToCosmosClaimResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgSendToCosmosClaimResponse {
            const message = new MsgSendToCosmosClaimResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSendToCosmosClaimResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSendToCosmosClaimResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSendToCosmosClaimResponse {
            return MsgSendToCosmosClaimResponse.deserialize(bytes);
        }
    }
    export class MsgBatchSendToEthClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            event_nonce?: number;
            block_height?: number;
            batch_nonce?: number;
            token_contract?: string;
            orchestrator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_nonce" in data && data.event_nonce != undefined) {
                    this.event_nonce = data.event_nonce;
                }
                if ("block_height" in data && data.block_height != undefined) {
                    this.block_height = data.block_height;
                }
                if ("batch_nonce" in data && data.batch_nonce != undefined) {
                    this.batch_nonce = data.batch_nonce;
                }
                if ("token_contract" in data && data.token_contract != undefined) {
                    this.token_contract = data.token_contract;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
            }
        }
        get event_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set event_nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get block_height() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set block_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get batch_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set batch_nonce(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get token_contract() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set token_contract(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            event_nonce?: number;
            block_height?: number;
            batch_nonce?: number;
            token_contract?: string;
            orchestrator?: string;
        }): MsgBatchSendToEthClaim {
            const message = new MsgBatchSendToEthClaim({});
            if (data.event_nonce != null) {
                message.event_nonce = data.event_nonce;
            }
            if (data.block_height != null) {
                message.block_height = data.block_height;
            }
            if (data.batch_nonce != null) {
                message.batch_nonce = data.batch_nonce;
            }
            if (data.token_contract != null) {
                message.token_contract = data.token_contract;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            return message;
        }
        toObject() {
            const data: {
                event_nonce?: number;
                block_height?: number;
                batch_nonce?: number;
                token_contract?: string;
                orchestrator?: string;
            } = {};
            if (this.event_nonce != null) {
                data.event_nonce = this.event_nonce;
            }
            if (this.block_height != null) {
                data.block_height = this.block_height;
            }
            if (this.batch_nonce != null) {
                data.batch_nonce = this.batch_nonce;
            }
            if (this.token_contract != null) {
                data.token_contract = this.token_contract;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_nonce != 0)
                writer.writeUint64(1, this.event_nonce);
            if (this.block_height != 0)
                writer.writeUint64(2, this.block_height);
            if (this.batch_nonce != 0)
                writer.writeUint64(3, this.batch_nonce);
            if (this.token_contract.length)
                writer.writeString(4, this.token_contract);
            if (this.orchestrator.length)
                writer.writeString(5, this.orchestrator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgBatchSendToEthClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgBatchSendToEthClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_nonce = reader.readUint64();
                        break;
                    case 2:
                        message.block_height = reader.readUint64();
                        break;
                    case 3:
                        message.batch_nonce = reader.readUint64();
                        break;
                    case 4:
                        message.token_contract = reader.readString();
                        break;
                    case 5:
                        message.orchestrator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgBatchSendToEthClaim {
            return MsgBatchSendToEthClaim.deserialize(bytes);
        }
    }
    export class MsgBatchSendToEthClaimResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgBatchSendToEthClaimResponse {
            const message = new MsgBatchSendToEthClaimResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgBatchSendToEthClaimResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgBatchSendToEthClaimResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgBatchSendToEthClaimResponse {
            return MsgBatchSendToEthClaimResponse.deserialize(bytes);
        }
    }
    export class MsgERC20DeployedClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            event_nonce?: number;
            block_height?: number;
            cosmos_denom?: string;
            token_contract?: string;
            name?: string;
            symbol?: string;
            decimals?: number;
            orchestrator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_nonce" in data && data.event_nonce != undefined) {
                    this.event_nonce = data.event_nonce;
                }
                if ("block_height" in data && data.block_height != undefined) {
                    this.block_height = data.block_height;
                }
                if ("cosmos_denom" in data && data.cosmos_denom != undefined) {
                    this.cosmos_denom = data.cosmos_denom;
                }
                if ("token_contract" in data && data.token_contract != undefined) {
                    this.token_contract = data.token_contract;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("symbol" in data && data.symbol != undefined) {
                    this.symbol = data.symbol;
                }
                if ("decimals" in data && data.decimals != undefined) {
                    this.decimals = data.decimals;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
            }
        }
        get event_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set event_nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get block_height() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set block_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get cosmos_denom() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set cosmos_denom(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get token_contract() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set token_contract(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get symbol() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set symbol(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get decimals() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set decimals(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            event_nonce?: number;
            block_height?: number;
            cosmos_denom?: string;
            token_contract?: string;
            name?: string;
            symbol?: string;
            decimals?: number;
            orchestrator?: string;
        }): MsgERC20DeployedClaim {
            const message = new MsgERC20DeployedClaim({});
            if (data.event_nonce != null) {
                message.event_nonce = data.event_nonce;
            }
            if (data.block_height != null) {
                message.block_height = data.block_height;
            }
            if (data.cosmos_denom != null) {
                message.cosmos_denom = data.cosmos_denom;
            }
            if (data.token_contract != null) {
                message.token_contract = data.token_contract;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.symbol != null) {
                message.symbol = data.symbol;
            }
            if (data.decimals != null) {
                message.decimals = data.decimals;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            return message;
        }
        toObject() {
            const data: {
                event_nonce?: number;
                block_height?: number;
                cosmos_denom?: string;
                token_contract?: string;
                name?: string;
                symbol?: string;
                decimals?: number;
                orchestrator?: string;
            } = {};
            if (this.event_nonce != null) {
                data.event_nonce = this.event_nonce;
            }
            if (this.block_height != null) {
                data.block_height = this.block_height;
            }
            if (this.cosmos_denom != null) {
                data.cosmos_denom = this.cosmos_denom;
            }
            if (this.token_contract != null) {
                data.token_contract = this.token_contract;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.symbol != null) {
                data.symbol = this.symbol;
            }
            if (this.decimals != null) {
                data.decimals = this.decimals;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_nonce != 0)
                writer.writeUint64(1, this.event_nonce);
            if (this.block_height != 0)
                writer.writeUint64(2, this.block_height);
            if (this.cosmos_denom.length)
                writer.writeString(3, this.cosmos_denom);
            if (this.token_contract.length)
                writer.writeString(4, this.token_contract);
            if (this.name.length)
                writer.writeString(5, this.name);
            if (this.symbol.length)
                writer.writeString(6, this.symbol);
            if (this.decimals != 0)
                writer.writeUint64(7, this.decimals);
            if (this.orchestrator.length)
                writer.writeString(8, this.orchestrator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgERC20DeployedClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgERC20DeployedClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_nonce = reader.readUint64();
                        break;
                    case 2:
                        message.block_height = reader.readUint64();
                        break;
                    case 3:
                        message.cosmos_denom = reader.readString();
                        break;
                    case 4:
                        message.token_contract = reader.readString();
                        break;
                    case 5:
                        message.name = reader.readString();
                        break;
                    case 6:
                        message.symbol = reader.readString();
                        break;
                    case 7:
                        message.decimals = reader.readUint64();
                        break;
                    case 8:
                        message.orchestrator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgERC20DeployedClaim {
            return MsgERC20DeployedClaim.deserialize(bytes);
        }
    }
    export class MsgERC20DeployedClaimResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgERC20DeployedClaimResponse {
            const message = new MsgERC20DeployedClaimResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgERC20DeployedClaimResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgERC20DeployedClaimResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgERC20DeployedClaimResponse {
            return MsgERC20DeployedClaimResponse.deserialize(bytes);
        }
    }
    export class MsgLogicCallExecutedClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            event_nonce?: number;
            block_height?: number;
            invalidation_id?: Uint8Array;
            invalidation_nonce?: number;
            orchestrator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_nonce" in data && data.event_nonce != undefined) {
                    this.event_nonce = data.event_nonce;
                }
                if ("block_height" in data && data.block_height != undefined) {
                    this.block_height = data.block_height;
                }
                if ("invalidation_id" in data && data.invalidation_id != undefined) {
                    this.invalidation_id = data.invalidation_id;
                }
                if ("invalidation_nonce" in data && data.invalidation_nonce != undefined) {
                    this.invalidation_nonce = data.invalidation_nonce;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
            }
        }
        get event_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set event_nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get block_height() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set block_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get invalidation_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set invalidation_id(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get invalidation_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set invalidation_nonce(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            event_nonce?: number;
            block_height?: number;
            invalidation_id?: Uint8Array;
            invalidation_nonce?: number;
            orchestrator?: string;
        }): MsgLogicCallExecutedClaim {
            const message = new MsgLogicCallExecutedClaim({});
            if (data.event_nonce != null) {
                message.event_nonce = data.event_nonce;
            }
            if (data.block_height != null) {
                message.block_height = data.block_height;
            }
            if (data.invalidation_id != null) {
                message.invalidation_id = data.invalidation_id;
            }
            if (data.invalidation_nonce != null) {
                message.invalidation_nonce = data.invalidation_nonce;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            return message;
        }
        toObject() {
            const data: {
                event_nonce?: number;
                block_height?: number;
                invalidation_id?: Uint8Array;
                invalidation_nonce?: number;
                orchestrator?: string;
            } = {};
            if (this.event_nonce != null) {
                data.event_nonce = this.event_nonce;
            }
            if (this.block_height != null) {
                data.block_height = this.block_height;
            }
            if (this.invalidation_id != null) {
                data.invalidation_id = this.invalidation_id;
            }
            if (this.invalidation_nonce != null) {
                data.invalidation_nonce = this.invalidation_nonce;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_nonce != 0)
                writer.writeUint64(1, this.event_nonce);
            if (this.block_height != 0)
                writer.writeUint64(2, this.block_height);
            if (this.invalidation_id.length)
                writer.writeBytes(3, this.invalidation_id);
            if (this.invalidation_nonce != 0)
                writer.writeUint64(4, this.invalidation_nonce);
            if (this.orchestrator.length)
                writer.writeString(5, this.orchestrator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgLogicCallExecutedClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgLogicCallExecutedClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_nonce = reader.readUint64();
                        break;
                    case 2:
                        message.block_height = reader.readUint64();
                        break;
                    case 3:
                        message.invalidation_id = reader.readBytes();
                        break;
                    case 4:
                        message.invalidation_nonce = reader.readUint64();
                        break;
                    case 5:
                        message.orchestrator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgLogicCallExecutedClaim {
            return MsgLogicCallExecutedClaim.deserialize(bytes);
        }
    }
    export class MsgLogicCallExecutedClaimResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgLogicCallExecutedClaimResponse {
            const message = new MsgLogicCallExecutedClaimResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgLogicCallExecutedClaimResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgLogicCallExecutedClaimResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgLogicCallExecutedClaimResponse {
            return MsgLogicCallExecutedClaimResponse.deserialize(bytes);
        }
    }
    export class MsgValsetUpdatedClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            event_nonce?: number;
            valset_nonce?: number;
            block_height?: number;
            members?: dependency_4.gravity.v1.BridgeValidator[];
            reward_amount?: string;
            reward_token?: string;
            orchestrator?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_nonce" in data && data.event_nonce != undefined) {
                    this.event_nonce = data.event_nonce;
                }
                if ("valset_nonce" in data && data.valset_nonce != undefined) {
                    this.valset_nonce = data.valset_nonce;
                }
                if ("block_height" in data && data.block_height != undefined) {
                    this.block_height = data.block_height;
                }
                if ("members" in data && data.members != undefined) {
                    this.members = data.members;
                }
                if ("reward_amount" in data && data.reward_amount != undefined) {
                    this.reward_amount = data.reward_amount;
                }
                if ("reward_token" in data && data.reward_token != undefined) {
                    this.reward_token = data.reward_token;
                }
                if ("orchestrator" in data && data.orchestrator != undefined) {
                    this.orchestrator = data.orchestrator;
                }
            }
        }
        get event_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set event_nonce(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get valset_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set valset_nonce(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_height() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set block_height(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get members() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_4.gravity.v1.BridgeValidator, 4) as dependency_4.gravity.v1.BridgeValidator[];
        }
        set members(value: dependency_4.gravity.v1.BridgeValidator[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get reward_amount() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set reward_amount(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get reward_token() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set reward_token(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get orchestrator() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set orchestrator(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            event_nonce?: number;
            valset_nonce?: number;
            block_height?: number;
            members?: ReturnType<typeof dependency_4.gravity.v1.BridgeValidator.prototype.toObject>[];
            reward_amount?: string;
            reward_token?: string;
            orchestrator?: string;
        }): MsgValsetUpdatedClaim {
            const message = new MsgValsetUpdatedClaim({});
            if (data.event_nonce != null) {
                message.event_nonce = data.event_nonce;
            }
            if (data.valset_nonce != null) {
                message.valset_nonce = data.valset_nonce;
            }
            if (data.block_height != null) {
                message.block_height = data.block_height;
            }
            if (data.members != null) {
                message.members = data.members.map(item => dependency_4.gravity.v1.BridgeValidator.fromObject(item));
            }
            if (data.reward_amount != null) {
                message.reward_amount = data.reward_amount;
            }
            if (data.reward_token != null) {
                message.reward_token = data.reward_token;
            }
            if (data.orchestrator != null) {
                message.orchestrator = data.orchestrator;
            }
            return message;
        }
        toObject() {
            const data: {
                event_nonce?: number;
                valset_nonce?: number;
                block_height?: number;
                members?: ReturnType<typeof dependency_4.gravity.v1.BridgeValidator.prototype.toObject>[];
                reward_amount?: string;
                reward_token?: string;
                orchestrator?: string;
            } = {};
            if (this.event_nonce != null) {
                data.event_nonce = this.event_nonce;
            }
            if (this.valset_nonce != null) {
                data.valset_nonce = this.valset_nonce;
            }
            if (this.block_height != null) {
                data.block_height = this.block_height;
            }
            if (this.members != null) {
                data.members = this.members.map((item: dependency_4.gravity.v1.BridgeValidator) => item.toObject());
            }
            if (this.reward_amount != null) {
                data.reward_amount = this.reward_amount;
            }
            if (this.reward_token != null) {
                data.reward_token = this.reward_token;
            }
            if (this.orchestrator != null) {
                data.orchestrator = this.orchestrator;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_nonce != 0)
                writer.writeUint64(1, this.event_nonce);
            if (this.valset_nonce != 0)
                writer.writeUint64(2, this.valset_nonce);
            if (this.block_height != 0)
                writer.writeUint64(3, this.block_height);
            if (this.members.length)
                writer.writeRepeatedMessage(4, this.members, (item: dependency_4.gravity.v1.BridgeValidator) => item.serialize(writer));
            if (this.reward_amount.length)
                writer.writeString(5, this.reward_amount);
            if (this.reward_token.length)
                writer.writeString(6, this.reward_token);
            if (this.orchestrator.length)
                writer.writeString(7, this.orchestrator);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgValsetUpdatedClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgValsetUpdatedClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_nonce = reader.readUint64();
                        break;
                    case 2:
                        message.valset_nonce = reader.readUint64();
                        break;
                    case 3:
                        message.block_height = reader.readUint64();
                        break;
                    case 4:
                        reader.readMessage(message.members, () => pb_1.Message.addToRepeatedWrapperField(message, 4, dependency_4.gravity.v1.BridgeValidator.deserialize(reader), dependency_4.gravity.v1.BridgeValidator));
                        break;
                    case 5:
                        message.reward_amount = reader.readString();
                        break;
                    case 6:
                        message.reward_token = reader.readString();
                        break;
                    case 7:
                        message.orchestrator = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgValsetUpdatedClaim {
            return MsgValsetUpdatedClaim.deserialize(bytes);
        }
    }
    export class MsgValsetUpdatedClaimResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgValsetUpdatedClaimResponse {
            const message = new MsgValsetUpdatedClaimResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgValsetUpdatedClaimResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgValsetUpdatedClaimResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgValsetUpdatedClaimResponse {
            return MsgValsetUpdatedClaimResponse.deserialize(bytes);
        }
    }
    export class MsgCancelSendToEth extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: number;
            sender?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set transaction_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sender() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            transaction_id?: number;
            sender?: string;
        }): MsgCancelSendToEth {
            const message = new MsgCancelSendToEth({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.sender != null) {
                message.sender = data.sender;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: number;
                sender?: string;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.sender != null) {
                data.sender = this.sender;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id != 0)
                writer.writeUint64(1, this.transaction_id);
            if (this.sender.length)
                writer.writeString(2, this.sender);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCancelSendToEth {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCancelSendToEth();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readUint64();
                        break;
                    case 2:
                        message.sender = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCancelSendToEth {
            return MsgCancelSendToEth.deserialize(bytes);
        }
    }
    export class MsgCancelSendToEthResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgCancelSendToEthResponse {
            const message = new MsgCancelSendToEthResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCancelSendToEthResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCancelSendToEthResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCancelSendToEthResponse {
            return MsgCancelSendToEthResponse.deserialize(bytes);
        }
    }
    export class MsgSubmitBadSignatureEvidence extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            subject?: dependency_5.google.protobuf.Any;
            signature?: string;
            sender?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("subject" in data && data.subject != undefined) {
                    this.subject = data.subject;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
            }
        }
        get subject() {
            return pb_1.Message.getWrapperField(this, dependency_5.google.protobuf.Any, 1) as dependency_5.google.protobuf.Any;
        }
        set subject(value: dependency_5.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_subject() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get signature() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set signature(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get sender() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            subject?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
            signature?: string;
            sender?: string;
        }): MsgSubmitBadSignatureEvidence {
            const message = new MsgSubmitBadSignatureEvidence({});
            if (data.subject != null) {
                message.subject = dependency_5.google.protobuf.Any.fromObject(data.subject);
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            if (data.sender != null) {
                message.sender = data.sender;
            }
            return message;
        }
        toObject() {
            const data: {
                subject?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
                signature?: string;
                sender?: string;
            } = {};
            if (this.subject != null) {
                data.subject = this.subject.toObject();
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            if (this.sender != null) {
                data.sender = this.sender;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_subject)
                writer.writeMessage(1, this.subject, () => this.subject.serialize(writer));
            if (this.signature.length)
                writer.writeString(2, this.signature);
            if (this.sender.length)
                writer.writeString(3, this.sender);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSubmitBadSignatureEvidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSubmitBadSignatureEvidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.subject, () => message.subject = dependency_5.google.protobuf.Any.deserialize(reader));
                        break;
                    case 2:
                        message.signature = reader.readString();
                        break;
                    case 3:
                        message.sender = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSubmitBadSignatureEvidence {
            return MsgSubmitBadSignatureEvidence.deserialize(bytes);
        }
    }
    export class MsgSubmitBadSignatureEvidenceResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgSubmitBadSignatureEvidenceResponse {
            const message = new MsgSubmitBadSignatureEvidenceResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSubmitBadSignatureEvidenceResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSubmitBadSignatureEvidenceResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSubmitBadSignatureEvidenceResponse {
            return MsgSubmitBadSignatureEvidenceResponse.deserialize(bytes);
        }
    }
    export class EventSetOperatorAddress extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            message?: string;
            address?: string;
        }): EventSetOperatorAddress {
            const message = new EventSetOperatorAddress({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                address?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.address.length)
                writer.writeString(2, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventSetOperatorAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventSetOperatorAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventSetOperatorAddress {
            return EventSetOperatorAddress.deserialize(bytes);
        }
    }
    export class EventValsetConfirmKey extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            key?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set key(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            message?: string;
            key?: string;
        }): EventValsetConfirmKey {
            const message = new EventValsetConfirmKey({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.key != null) {
                message.key = data.key;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                key?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.key != null) {
                data.key = this.key;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.key.length)
                writer.writeString(2, this.key);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventValsetConfirmKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventValsetConfirmKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.key = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventValsetConfirmKey {
            return EventValsetConfirmKey.deserialize(bytes);
        }
    }
    export class EventBatchCreated extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            batch_nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("batch_nonce" in data && data.batch_nonce != undefined) {
                    this.batch_nonce = data.batch_nonce;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get batch_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set batch_nonce(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            message?: string;
            batch_nonce?: string;
        }): EventBatchCreated {
            const message = new EventBatchCreated({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.batch_nonce != null) {
                message.batch_nonce = data.batch_nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                batch_nonce?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.batch_nonce != null) {
                data.batch_nonce = this.batch_nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.batch_nonce.length)
                writer.writeString(2, this.batch_nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventBatchCreated {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventBatchCreated();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.batch_nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventBatchCreated {
            return EventBatchCreated.deserialize(bytes);
        }
    }
    export class EventBatchConfirmKey extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            batch_confirm_key?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("batch_confirm_key" in data && data.batch_confirm_key != undefined) {
                    this.batch_confirm_key = data.batch_confirm_key;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get batch_confirm_key() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set batch_confirm_key(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            message?: string;
            batch_confirm_key?: string;
        }): EventBatchConfirmKey {
            const message = new EventBatchConfirmKey({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.batch_confirm_key != null) {
                message.batch_confirm_key = data.batch_confirm_key;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                batch_confirm_key?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.batch_confirm_key != null) {
                data.batch_confirm_key = this.batch_confirm_key;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.batch_confirm_key.length)
                writer.writeString(2, this.batch_confirm_key);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventBatchConfirmKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventBatchConfirmKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.batch_confirm_key = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventBatchConfirmKey {
            return EventBatchConfirmKey.deserialize(bytes);
        }
    }
    export class EventBatchSendToEthClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
            }
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set nonce(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            nonce?: string;
        }): EventBatchSendToEthClaim {
            const message = new EventBatchSendToEthClaim({});
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                nonce?: string;
            } = {};
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.nonce.length)
                writer.writeString(1, this.nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventBatchSendToEthClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventBatchSendToEthClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventBatchSendToEthClaim {
            return EventBatchSendToEthClaim.deserialize(bytes);
        }
    }
    export class EventClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            claim_hash?: string;
            attestation_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("claim_hash" in data && data.claim_hash != undefined) {
                    this.claim_hash = data.claim_hash;
                }
                if ("attestation_id" in data && data.attestation_id != undefined) {
                    this.attestation_id = data.attestation_id;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get claim_hash() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set claim_hash(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get attestation_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set attestation_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            message?: string;
            claim_hash?: string;
            attestation_id?: string;
        }): EventClaim {
            const message = new EventClaim({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.claim_hash != null) {
                message.claim_hash = data.claim_hash;
            }
            if (data.attestation_id != null) {
                message.attestation_id = data.attestation_id;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                claim_hash?: string;
                attestation_id?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.claim_hash != null) {
                data.claim_hash = this.claim_hash;
            }
            if (this.attestation_id != null) {
                data.attestation_id = this.attestation_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.claim_hash.length)
                writer.writeString(2, this.claim_hash);
            if (this.attestation_id.length)
                writer.writeString(3, this.attestation_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.claim_hash = reader.readString();
                        break;
                    case 3:
                        message.attestation_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventClaim {
            return EventClaim.deserialize(bytes);
        }
    }
    export class EventBadSignatureEvidence extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            bad_eth_signature?: string;
            bad_eth_signature_subject?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("bad_eth_signature" in data && data.bad_eth_signature != undefined) {
                    this.bad_eth_signature = data.bad_eth_signature;
                }
                if ("bad_eth_signature_subject" in data && data.bad_eth_signature_subject != undefined) {
                    this.bad_eth_signature_subject = data.bad_eth_signature_subject;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get bad_eth_signature() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set bad_eth_signature(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get bad_eth_signature_subject() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set bad_eth_signature_subject(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            message?: string;
            bad_eth_signature?: string;
            bad_eth_signature_subject?: string;
        }): EventBadSignatureEvidence {
            const message = new EventBadSignatureEvidence({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.bad_eth_signature != null) {
                message.bad_eth_signature = data.bad_eth_signature;
            }
            if (data.bad_eth_signature_subject != null) {
                message.bad_eth_signature_subject = data.bad_eth_signature_subject;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                bad_eth_signature?: string;
                bad_eth_signature_subject?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.bad_eth_signature != null) {
                data.bad_eth_signature = this.bad_eth_signature;
            }
            if (this.bad_eth_signature_subject != null) {
                data.bad_eth_signature_subject = this.bad_eth_signature_subject;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.bad_eth_signature.length)
                writer.writeString(2, this.bad_eth_signature);
            if (this.bad_eth_signature_subject.length)
                writer.writeString(3, this.bad_eth_signature_subject);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventBadSignatureEvidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventBadSignatureEvidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.bad_eth_signature = reader.readString();
                        break;
                    case 3:
                        message.bad_eth_signature_subject = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventBadSignatureEvidence {
            return EventBadSignatureEvidence.deserialize(bytes);
        }
    }
    export class EventERC20DeployedClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            token?: string;
            nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("token" in data && data.token != undefined) {
                    this.token = data.token;
                }
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
            }
        }
        get token() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set token(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set nonce(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            token?: string;
            nonce?: string;
        }): EventERC20DeployedClaim {
            const message = new EventERC20DeployedClaim({});
            if (data.token != null) {
                message.token = data.token;
            }
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                token?: string;
                nonce?: string;
            } = {};
            if (this.token != null) {
                data.token = this.token;
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.token.length)
                writer.writeString(1, this.token);
            if (this.nonce.length)
                writer.writeString(2, this.nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventERC20DeployedClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventERC20DeployedClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.token = reader.readString();
                        break;
                    case 2:
                        message.nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventERC20DeployedClaim {
            return EventERC20DeployedClaim.deserialize(bytes);
        }
    }
    export class EventValsetUpdatedClaim extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
            }
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set nonce(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            nonce?: string;
        }): EventValsetUpdatedClaim {
            const message = new EventValsetUpdatedClaim({});
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                nonce?: string;
            } = {};
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.nonce.length)
                writer.writeString(1, this.nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventValsetUpdatedClaim {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventValsetUpdatedClaim();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventValsetUpdatedClaim {
            return EventValsetUpdatedClaim.deserialize(bytes);
        }
    }
    export class EventMultisigUpdateRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            bridge_contract?: string;
            bridge_chain_id?: string;
            multisig_id?: string;
            nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("bridge_contract" in data && data.bridge_contract != undefined) {
                    this.bridge_contract = data.bridge_contract;
                }
                if ("bridge_chain_id" in data && data.bridge_chain_id != undefined) {
                    this.bridge_chain_id = data.bridge_chain_id;
                }
                if ("multisig_id" in data && data.multisig_id != undefined) {
                    this.multisig_id = data.multisig_id;
                }
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
            }
        }
        get bridge_contract() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set bridge_contract(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get bridge_chain_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set bridge_chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get multisig_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set multisig_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set nonce(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            bridge_contract?: string;
            bridge_chain_id?: string;
            multisig_id?: string;
            nonce?: string;
        }): EventMultisigUpdateRequest {
            const message = new EventMultisigUpdateRequest({});
            if (data.bridge_contract != null) {
                message.bridge_contract = data.bridge_contract;
            }
            if (data.bridge_chain_id != null) {
                message.bridge_chain_id = data.bridge_chain_id;
            }
            if (data.multisig_id != null) {
                message.multisig_id = data.multisig_id;
            }
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                bridge_contract?: string;
                bridge_chain_id?: string;
                multisig_id?: string;
                nonce?: string;
            } = {};
            if (this.bridge_contract != null) {
                data.bridge_contract = this.bridge_contract;
            }
            if (this.bridge_chain_id != null) {
                data.bridge_chain_id = this.bridge_chain_id;
            }
            if (this.multisig_id != null) {
                data.multisig_id = this.multisig_id;
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.bridge_contract.length)
                writer.writeString(1, this.bridge_contract);
            if (this.bridge_chain_id.length)
                writer.writeString(2, this.bridge_chain_id);
            if (this.multisig_id.length)
                writer.writeString(3, this.multisig_id);
            if (this.nonce.length)
                writer.writeString(4, this.nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventMultisigUpdateRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventMultisigUpdateRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.bridge_contract = reader.readString();
                        break;
                    case 2:
                        message.bridge_chain_id = reader.readString();
                        break;
                    case 3:
                        message.multisig_id = reader.readString();
                        break;
                    case 4:
                        message.nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventMultisigUpdateRequest {
            return EventMultisigUpdateRequest.deserialize(bytes);
        }
    }
    export class EventOutgoingLogicCallCanceled extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            logic_call_invalidation_id?: string;
            logic_call_invalidation_nonce?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("logic_call_invalidation_id" in data && data.logic_call_invalidation_id != undefined) {
                    this.logic_call_invalidation_id = data.logic_call_invalidation_id;
                }
                if ("logic_call_invalidation_nonce" in data && data.logic_call_invalidation_nonce != undefined) {
                    this.logic_call_invalidation_nonce = data.logic_call_invalidation_nonce;
                }
            }
        }
        get logic_call_invalidation_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set logic_call_invalidation_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get logic_call_invalidation_nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set logic_call_invalidation_nonce(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            logic_call_invalidation_id?: string;
            logic_call_invalidation_nonce?: string;
        }): EventOutgoingLogicCallCanceled {
            const message = new EventOutgoingLogicCallCanceled({});
            if (data.logic_call_invalidation_id != null) {
                message.logic_call_invalidation_id = data.logic_call_invalidation_id;
            }
            if (data.logic_call_invalidation_nonce != null) {
                message.logic_call_invalidation_nonce = data.logic_call_invalidation_nonce;
            }
            return message;
        }
        toObject() {
            const data: {
                logic_call_invalidation_id?: string;
                logic_call_invalidation_nonce?: string;
            } = {};
            if (this.logic_call_invalidation_id != null) {
                data.logic_call_invalidation_id = this.logic_call_invalidation_id;
            }
            if (this.logic_call_invalidation_nonce != null) {
                data.logic_call_invalidation_nonce = this.logic_call_invalidation_nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.logic_call_invalidation_id.length)
                writer.writeString(1, this.logic_call_invalidation_id);
            if (this.logic_call_invalidation_nonce.length)
                writer.writeString(2, this.logic_call_invalidation_nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventOutgoingLogicCallCanceled {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventOutgoingLogicCallCanceled();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.logic_call_invalidation_id = reader.readString();
                        break;
                    case 2:
                        message.logic_call_invalidation_nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventOutgoingLogicCallCanceled {
            return EventOutgoingLogicCallCanceled.deserialize(bytes);
        }
    }
    export class EventSignatureSlashing extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: string;
            address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type?: string;
            address?: string;
        }): EventSignatureSlashing {
            const message = new EventSignatureSlashing({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.address != null) {
                message.address = data.address;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: string;
                address?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.address != null) {
                data.address = this.address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type.length)
                writer.writeString(1, this.type);
            if (this.address.length)
                writer.writeString(2, this.address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventSignatureSlashing {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventSignatureSlashing();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readString();
                        break;
                    case 2:
                        message.address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventSignatureSlashing {
            return EventSignatureSlashing.deserialize(bytes);
        }
    }
    export class EventOutgoingTxId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message?: string;
            tx_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("tx_id" in data && data.tx_id != undefined) {
                    this.tx_id = data.tx_id;
                }
            }
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get tx_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set tx_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            message?: string;
            tx_id?: string;
        }): EventOutgoingTxId {
            const message = new EventOutgoingTxId({});
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.tx_id != null) {
                message.tx_id = data.tx_id;
            }
            return message;
        }
        toObject() {
            const data: {
                message?: string;
                tx_id?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.tx_id != null) {
                data.tx_id = this.tx_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.message.length)
                writer.writeString(1, this.message);
            if (this.tx_id.length)
                writer.writeString(2, this.tx_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventOutgoingTxId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventOutgoingTxId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    case 2:
                        message.tx_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventOutgoingTxId {
            return EventOutgoingTxId.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedMsgService {
        static definition = {
            ValsetConfirm: {
                path: "/gravity.v1.Msg/ValsetConfirm",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgValsetConfirm) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgValsetConfirm.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgValsetConfirmResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgValsetConfirmResponse.deserialize(new Uint8Array(bytes))
            },
            SendToEth: {
                path: "/gravity.v1.Msg/SendToEth",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgSendToEth) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgSendToEth.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgSendToEthResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgSendToEthResponse.deserialize(new Uint8Array(bytes))
            },
            RequestBatch: {
                path: "/gravity.v1.Msg/RequestBatch",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgRequestBatch) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgRequestBatch.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgRequestBatchResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgRequestBatchResponse.deserialize(new Uint8Array(bytes))
            },
            ConfirmBatch: {
                path: "/gravity.v1.Msg/ConfirmBatch",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgConfirmBatch) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgConfirmBatch.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgConfirmBatchResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgConfirmBatchResponse.deserialize(new Uint8Array(bytes))
            },
            ConfirmLogicCall: {
                path: "/gravity.v1.Msg/ConfirmLogicCall",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgConfirmLogicCall) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgConfirmLogicCall.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgConfirmLogicCallResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgConfirmLogicCallResponse.deserialize(new Uint8Array(bytes))
            },
            SendToCosmosClaim: {
                path: "/gravity.v1.Msg/SendToCosmosClaim",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgSendToCosmosClaim) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgSendToCosmosClaim.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgSendToCosmosClaimResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgSendToCosmosClaimResponse.deserialize(new Uint8Array(bytes))
            },
            BatchSendToEthClaim: {
                path: "/gravity.v1.Msg/BatchSendToEthClaim",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgBatchSendToEthClaim) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgBatchSendToEthClaim.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgBatchSendToEthClaimResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgBatchSendToEthClaimResponse.deserialize(new Uint8Array(bytes))
            },
            ValsetUpdateClaim: {
                path: "/gravity.v1.Msg/ValsetUpdateClaim",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgValsetUpdatedClaim) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgValsetUpdatedClaim.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgValsetUpdatedClaimResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgValsetUpdatedClaimResponse.deserialize(new Uint8Array(bytes))
            },
            ERC20DeployedClaim: {
                path: "/gravity.v1.Msg/ERC20DeployedClaim",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgERC20DeployedClaim) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgERC20DeployedClaim.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgERC20DeployedClaimResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgERC20DeployedClaimResponse.deserialize(new Uint8Array(bytes))
            },
            LogicCallExecutedClaim: {
                path: "/gravity.v1.Msg/LogicCallExecutedClaim",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgLogicCallExecutedClaim) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgLogicCallExecutedClaim.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgLogicCallExecutedClaimResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgLogicCallExecutedClaimResponse.deserialize(new Uint8Array(bytes))
            },
            SetOrchestratorAddress: {
                path: "/gravity.v1.Msg/SetOrchestratorAddress",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgSetOrchestratorAddress) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgSetOrchestratorAddress.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgSetOrchestratorAddressResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgSetOrchestratorAddressResponse.deserialize(new Uint8Array(bytes))
            },
            CancelSendToEth: {
                path: "/gravity.v1.Msg/CancelSendToEth",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgCancelSendToEth) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgCancelSendToEth.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgCancelSendToEthResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgCancelSendToEthResponse.deserialize(new Uint8Array(bytes))
            },
            SubmitBadSignatureEvidence: {
                path: "/gravity.v1.Msg/SubmitBadSignatureEvidence",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: MsgSubmitBadSignatureEvidence) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => MsgSubmitBadSignatureEvidence.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: MsgSubmitBadSignatureEvidenceResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => MsgSubmitBadSignatureEvidenceResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract ValsetConfirm(call: grpc_1.ServerUnaryCall<MsgValsetConfirm, MsgValsetConfirmResponse>, callback: grpc_1.sendUnaryData<MsgValsetConfirmResponse>): void;
        abstract SendToEth(call: grpc_1.ServerUnaryCall<MsgSendToEth, MsgSendToEthResponse>, callback: grpc_1.sendUnaryData<MsgSendToEthResponse>): void;
        abstract RequestBatch(call: grpc_1.ServerUnaryCall<MsgRequestBatch, MsgRequestBatchResponse>, callback: grpc_1.sendUnaryData<MsgRequestBatchResponse>): void;
        abstract ConfirmBatch(call: grpc_1.ServerUnaryCall<MsgConfirmBatch, MsgConfirmBatchResponse>, callback: grpc_1.sendUnaryData<MsgConfirmBatchResponse>): void;
        abstract ConfirmLogicCall(call: grpc_1.ServerUnaryCall<MsgConfirmLogicCall, MsgConfirmLogicCallResponse>, callback: grpc_1.sendUnaryData<MsgConfirmLogicCallResponse>): void;
        abstract SendToCosmosClaim(call: grpc_1.ServerUnaryCall<MsgSendToCosmosClaim, MsgSendToCosmosClaimResponse>, callback: grpc_1.sendUnaryData<MsgSendToCosmosClaimResponse>): void;
        abstract BatchSendToEthClaim(call: grpc_1.ServerUnaryCall<MsgBatchSendToEthClaim, MsgBatchSendToEthClaimResponse>, callback: grpc_1.sendUnaryData<MsgBatchSendToEthClaimResponse>): void;
        abstract ValsetUpdateClaim(call: grpc_1.ServerUnaryCall<MsgValsetUpdatedClaim, MsgValsetUpdatedClaimResponse>, callback: grpc_1.sendUnaryData<MsgValsetUpdatedClaimResponse>): void;
        abstract ERC20DeployedClaim(call: grpc_1.ServerUnaryCall<MsgERC20DeployedClaim, MsgERC20DeployedClaimResponse>, callback: grpc_1.sendUnaryData<MsgERC20DeployedClaimResponse>): void;
        abstract LogicCallExecutedClaim(call: grpc_1.ServerUnaryCall<MsgLogicCallExecutedClaim, MsgLogicCallExecutedClaimResponse>, callback: grpc_1.sendUnaryData<MsgLogicCallExecutedClaimResponse>): void;
        abstract SetOrchestratorAddress(call: grpc_1.ServerUnaryCall<MsgSetOrchestratorAddress, MsgSetOrchestratorAddressResponse>, callback: grpc_1.sendUnaryData<MsgSetOrchestratorAddressResponse>): void;
        abstract CancelSendToEth(call: grpc_1.ServerUnaryCall<MsgCancelSendToEth, MsgCancelSendToEthResponse>, callback: grpc_1.sendUnaryData<MsgCancelSendToEthResponse>): void;
        abstract SubmitBadSignatureEvidence(call: grpc_1.ServerUnaryCall<MsgSubmitBadSignatureEvidence, MsgSubmitBadSignatureEvidenceResponse>, callback: grpc_1.sendUnaryData<MsgSubmitBadSignatureEvidenceResponse>): void;
    }
    export class MsgClient extends grpc_1.makeGenericClientConstructor(UnimplementedMsgService.definition, "Msg", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        ValsetConfirm: GrpcUnaryServiceInterface<MsgValsetConfirm, MsgValsetConfirmResponse> = (message: MsgValsetConfirm, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgValsetConfirmResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgValsetConfirmResponse>, callback?: grpc_1.requestCallback<MsgValsetConfirmResponse>): grpc_1.ClientUnaryCall => {
            return super.ValsetConfirm(message, metadata, options, callback);
        };
        SendToEth: GrpcUnaryServiceInterface<MsgSendToEth, MsgSendToEthResponse> = (message: MsgSendToEth, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgSendToEthResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgSendToEthResponse>, callback?: grpc_1.requestCallback<MsgSendToEthResponse>): grpc_1.ClientUnaryCall => {
            return super.SendToEth(message, metadata, options, callback);
        };
        RequestBatch: GrpcUnaryServiceInterface<MsgRequestBatch, MsgRequestBatchResponse> = (message: MsgRequestBatch, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgRequestBatchResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgRequestBatchResponse>, callback?: grpc_1.requestCallback<MsgRequestBatchResponse>): grpc_1.ClientUnaryCall => {
            return super.RequestBatch(message, metadata, options, callback);
        };
        ConfirmBatch: GrpcUnaryServiceInterface<MsgConfirmBatch, MsgConfirmBatchResponse> = (message: MsgConfirmBatch, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgConfirmBatchResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgConfirmBatchResponse>, callback?: grpc_1.requestCallback<MsgConfirmBatchResponse>): grpc_1.ClientUnaryCall => {
            return super.ConfirmBatch(message, metadata, options, callback);
        };
        ConfirmLogicCall: GrpcUnaryServiceInterface<MsgConfirmLogicCall, MsgConfirmLogicCallResponse> = (message: MsgConfirmLogicCall, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgConfirmLogicCallResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgConfirmLogicCallResponse>, callback?: grpc_1.requestCallback<MsgConfirmLogicCallResponse>): grpc_1.ClientUnaryCall => {
            return super.ConfirmLogicCall(message, metadata, options, callback);
        };
        SendToCosmosClaim: GrpcUnaryServiceInterface<MsgSendToCosmosClaim, MsgSendToCosmosClaimResponse> = (message: MsgSendToCosmosClaim, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgSendToCosmosClaimResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgSendToCosmosClaimResponse>, callback?: grpc_1.requestCallback<MsgSendToCosmosClaimResponse>): grpc_1.ClientUnaryCall => {
            return super.SendToCosmosClaim(message, metadata, options, callback);
        };
        BatchSendToEthClaim: GrpcUnaryServiceInterface<MsgBatchSendToEthClaim, MsgBatchSendToEthClaimResponse> = (message: MsgBatchSendToEthClaim, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgBatchSendToEthClaimResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgBatchSendToEthClaimResponse>, callback?: grpc_1.requestCallback<MsgBatchSendToEthClaimResponse>): grpc_1.ClientUnaryCall => {
            return super.BatchSendToEthClaim(message, metadata, options, callback);
        };
        ValsetUpdateClaim: GrpcUnaryServiceInterface<MsgValsetUpdatedClaim, MsgValsetUpdatedClaimResponse> = (message: MsgValsetUpdatedClaim, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgValsetUpdatedClaimResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgValsetUpdatedClaimResponse>, callback?: grpc_1.requestCallback<MsgValsetUpdatedClaimResponse>): grpc_1.ClientUnaryCall => {
            return super.ValsetUpdateClaim(message, metadata, options, callback);
        };
        ERC20DeployedClaim: GrpcUnaryServiceInterface<MsgERC20DeployedClaim, MsgERC20DeployedClaimResponse> = (message: MsgERC20DeployedClaim, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgERC20DeployedClaimResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgERC20DeployedClaimResponse>, callback?: grpc_1.requestCallback<MsgERC20DeployedClaimResponse>): grpc_1.ClientUnaryCall => {
            return super.ERC20DeployedClaim(message, metadata, options, callback);
        };
        LogicCallExecutedClaim: GrpcUnaryServiceInterface<MsgLogicCallExecutedClaim, MsgLogicCallExecutedClaimResponse> = (message: MsgLogicCallExecutedClaim, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgLogicCallExecutedClaimResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgLogicCallExecutedClaimResponse>, callback?: grpc_1.requestCallback<MsgLogicCallExecutedClaimResponse>): grpc_1.ClientUnaryCall => {
            return super.LogicCallExecutedClaim(message, metadata, options, callback);
        };
        SetOrchestratorAddress: GrpcUnaryServiceInterface<MsgSetOrchestratorAddress, MsgSetOrchestratorAddressResponse> = (message: MsgSetOrchestratorAddress, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgSetOrchestratorAddressResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgSetOrchestratorAddressResponse>, callback?: grpc_1.requestCallback<MsgSetOrchestratorAddressResponse>): grpc_1.ClientUnaryCall => {
            return super.SetOrchestratorAddress(message, metadata, options, callback);
        };
        CancelSendToEth: GrpcUnaryServiceInterface<MsgCancelSendToEth, MsgCancelSendToEthResponse> = (message: MsgCancelSendToEth, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgCancelSendToEthResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgCancelSendToEthResponse>, callback?: grpc_1.requestCallback<MsgCancelSendToEthResponse>): grpc_1.ClientUnaryCall => {
            return super.CancelSendToEth(message, metadata, options, callback);
        };
        SubmitBadSignatureEvidence: GrpcUnaryServiceInterface<MsgSubmitBadSignatureEvidence, MsgSubmitBadSignatureEvidenceResponse> = (message: MsgSubmitBadSignatureEvidence, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<MsgSubmitBadSignatureEvidenceResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<MsgSubmitBadSignatureEvidenceResponse>, callback?: grpc_1.requestCallback<MsgSubmitBadSignatureEvidenceResponse>): grpc_1.ClientUnaryCall => {
            return super.SubmitBadSignatureEvidence(message, metadata, options, callback);
        };
    }
}
